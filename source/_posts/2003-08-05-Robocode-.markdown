---
layout: post
title: "Robocode的线程与执行次序"
comments: true
date: 2003-08-05 22:59
tags:
- SoftwareDev
---
Robocode的每个机器人都是一个线程，线程调度为非强占式，由战斗管理线程依次调度运行。每个线程执行到一个阻塞函数的时候，交出cpu占用权。对于AdvancedRobot，阻塞函数是excute()。  
  
从这个角度而言，可以把robocode看作是回合制的游戏，每个回合各个robot设定要做些什么操作，即调用setXXX()，调用excute()完成本回合的操作设定。各个robot都设定完后，战斗模拟模块模拟执行各个robot的动作，并且在屏幕显示结果。下个回合，robot线程在excute()下面继续执行，直到再次调用excute()为止。  
  
不过，setXXX()设定的操作，往往是在一个回合中执行不完的。在robocode中，一个回合是游戏中的一个时间单位，各个元素的运动都有一定的速度，需要一定单位的时间才能完成。如果上回合中设置的动作还没有完成，本回合又重新设定了，就会把新动作覆盖旧动作。  
  
事件处理函数onXXX()，看起来是在事件发生的时候立即执行的，其实不然，还是要在回合中轮到这个robot的时候才能执行。而且若在队列中有多个事件，而某个事件处理函数调用了excute()结束了本回合的动作，那么剩下的事件就要等到下个回合才能处理了。因此，onXXX()改变的只是某个线程内部的执行次序，并不改变robot线程之间的执行次序。  


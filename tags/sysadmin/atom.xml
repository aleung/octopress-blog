<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: SysAdmin | Good good study, day day up]]></title>
  <link href="http://aleung.github.io/blog/tags/sysadmin/atom.xml" rel="self"/>
  <link href="http://aleung.github.io/blog/"/>
  <updated>2015-09-20T12:42:21+08:00</updated>
  <id>http://aleung.github.io/blog/</id>
  <author>
    <name><![CDATA[Leo Liang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Trouble shooting: Windows响应缓慢]]></title>
    <link href="http://aleung.github.io/blog/2014/12/30/windows-troubleshooting/"/>
    <updated>2014-12-30T16:24:15+08:00</updated>
    <id>http://aleung.github.io/blog/2014/12/30/windows-troubleshooting</id>
    <content type="html"><![CDATA[<p>最近一个星期，电脑出现了缓慢的现象：打开任何应用，窗口都要等待上一段时间才能出现。</p>

<p>在 <a href="http://technet.microsoft.com/en-us/sysinternals/bb896653">Process Explorer</a> 中看到进程已经出现，也没有什么CPU占用，但窗口就是不出来，好像是要等到什么操作超时。这里如果能够查看调用栈，应该就能知道程序卡在什么地方。</p>

<p>上网搜索一下，看到一些文章提到 troubleshoot Windows 问题，都用到了 WinDbg 来分析进程调用栈。这篇<a href="http://www.codeproject.com/Articles/6084/Windows-Debuggers-Part-A-WinDbg-Tutorial">文章</a>简要介绍了 WinDbg 的使用方法（不过可能文章年代过于久远，有些细节已经对不上了）。于是安装相应软件，实操一下。</p>

<p>只是用到 WinDbg 的一些皮毛功能，包括这些命令：</p>

<table>
  <thead>
    <tr>
      <th>Command</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>~</td>
      <td>列出所有线程</td>
    </tr>
    <tr>
      <td>k <em>5</em></td>
      <td>显示当前线程的stack trace，如果附带数字则限制打印条数</td>
    </tr>
    <tr>
      <td>kb</td>
      <td>显示stack trace，包含前三个调用参数</td>
    </tr>
    <tr>
      <td>~n[cmd]</td>
      <td>对n号线程执行 <em>cmd</em> 操作</td>
    </tr>
    <tr>
      <td>~*[cmd]</td>
      <td>对所有线程执行操作，如 <code>~*k 5</code></td>
    </tr>
    <tr>
      <td>~ns</td>
      <td>切换到n号线程</td>
    </tr>
  </tbody>
</table>

<p>WinDbg 可以 attach 到一个执行中的进程。但我只是想看看某个时刻那个进程在干什么，用 Process Explorer 创建进程的 minidump 更加简单，在 GUI 中选择进程，右键菜单选择 dump 就能创建出 dump 文件，可以多 dump 几次，然后用WinDbg 打开 dump 文件查看。</p>

<pre><code>Loading Dump File [C:\tmp\2014-12\notepad++.dmp]
User Mini Dump File: Only registers, stack and portions of memory are available

Symbol search path is: srv*c:\LocalSymbols* http://msdl.microsoft.com/download/symbols
Executable search path is:
Windows 7 Version 7601 (Service Pack 1) MP (4 procs) Free x86 compatible
Product: WinNt, suite: SingleUserTS
Machine Name:
Debug session time: Tue Dec 30 15:53:27.000 2014 (UTC + 8:00)
System Uptime: not available
Process Uptime: 0 days 0:00:06.000
</code></pre>

<p>这是 notepad++ 启动6秒钟后的 dump，看看这时有些什么线程，分别在干什么：</p>

<pre><code>0:000&gt; ~*k 6

.  0  Id: 1894.d54 Suspend: 0 Teb: 7efdd000 Unfrozen
ChildEBP RetAddr 
00137980 74c314ab ntdll!NtWaitForSingleObject+0x15
001379ec 764b1194 KERNELBASE!WaitForSingleObjectEx+0x98
00137a04 764b1148 kernel32!WaitForSingleObjectExImplementation+0x75
00137a18 74a5098c kernel32!WaitForSingleObject+0x12
00137a28 74a4fcdc msctf!CCicEvent::Wait+0x15
00137ca4 74a4fbd9 msctf!CAssemblyList::LoadFromCache+0x94

   1  Id: 1894.107c Suspend: 0 Teb: 7efda000 Unfrozen
ChildEBP RetAddr 
WARNING: Frame IP not in any known module. Following frames may be wrong.
00b4ff88 764b338a 0x1e02d1
00b4ff94 76ecbf32 kernel32!BaseThreadInitThunk+0xe
00b4ffd4 76ecbf05 ntdll!__RtlUserThreadStart+0x70
00b4ffec 00000000 ntdll!_RtlUserThreadStart+0x1b

   2  Id: 1894.4bc Suspend: 0 Teb: 7efd7000 Unfrozen
ChildEBP RetAddr 
02ecfe28 76ee1ad0 ntdll!NtWaitForWorkViaWorkerFactory+0x12
02ecff88 764b338a ntdll!TppWorkerThread+0x216
02ecff94 76ecbf32 kernel32!BaseThreadInitThunk+0xe
02ecffd4 76ecbf05 ntdll!__RtlUserThreadStart+0x70
02ecffec 00000000 ntdll!_RtlUserThreadStart+0x1b

   3  Id: 1894.f30 Suspend: 0 Teb: 7ef9f000 Unfrozen
ChildEBP RetAddr 
033afe28 76ee1ad0 ntdll!NtWaitForWorkViaWorkerFactory+0x12
033aff88 764b338a ntdll!TppWorkerThread+0x216
033aff94 76ecbf32 kernel32!BaseThreadInitThunk+0xe
033affd4 76ecbf05 ntdll!__RtlUserThreadStart+0x70
033affec 00000000 ntdll!_RtlUserThreadStart+0x1b

   4  Id: 1894.2034 Suspend: 0 Teb: 7ef9c000 Unfrozen
ChildEBP RetAddr 
04d1fdf4 76ecc6c5 ntdll!NtWaitForMultipleObjects+0x15
04d1ff88 764b338a ntdll!TppWaiterpThread+0x33d
04d1ff94 76ecbf32 kernel32!BaseThreadInitThunk+0xe
04d1ffd4 76ecbf05 ntdll!__RtlUserThreadStart+0x70
04d1ffec 00000000 ntdll!_RtlUserThreadStart+0x1b
</code></pre>

<p>共有5个线程，只有0号线程在干活。看0号线程的完整调用栈：</p>

<pre><code>0:000&gt; k
ChildEBP RetAddr 
00137980 74c314ab ntdll!NtWaitForSingleObject+0x15
001379ec 764b1194 KERNELBASE!WaitForSingleObjectEx+0x98
00137a04 764b1148 kernel32!WaitForSingleObjectExImplementation+0x75
00137a18 74a5098c kernel32!WaitForSingleObject+0x12
00137a28 74a4fcdc msctf!CCicEvent::Wait+0x15
00137ca4 74a4fbd9 msctf!CAssemblyList::LoadFromCache+0x94
00137cd0 74a4e045 msctf!CAssemblyList::Load+0x39
00137d00 74a4e863 msctf!EnsureAssemblyList+0xe9
00137d28 74a4e30a msctf!CLangBarItemMgr::GetCurrentCategoryList+0x14
00137d44 74a4e67d msctf!CLangBarItemMgr::_Init+0xea
00137d58 74a7d0c4 msctf!CLangBarItemMgr::CreateInstance+0xea
00137d78 74a57f99 msctf!CLangBarItemMgr_Ole::CreateInstance+0x6e
00137d8c 76038ca6 msctf!CClassFactory::CreateInstance+0x14
00137e14 76053170 ole32!CServerContextActivator::CreateInstance+0x172 [d:\w7rtm\com\ole32\com\objact\actvator.cxx @ 1000]
00137e54 76038dca ole32!ActivationPropertiesIn::DelegateCreateInstance+0x108 [d:\w7rtm\com\ole32\actprops\actprops.cxx @ 1917]
00137ea8 76038d3f ole32!CApartmentActivator::CreateInstance+0x112 [d:\w7rtm\com\ole32\com\objact\actvator.cxx @ 2268]
00137ec8 76038ac2 ole32!CProcessActivator::CCICallback+0x6d [d:\w7rtm\com\ole32\com\objact\actvator.cxx @ 1737]
00137ee8 76038a73 ole32!CProcessActivator::AttemptActivation+0x2c [d:\w7rtm\com\ole32\com\objact\actvator.cxx @ 1630]
00137f24 76038e2d ole32!CProcessActivator::ActivateByContext+0x4f [d:\w7rtm\com\ole32\com\objact\actvator.cxx @ 1487]
00137f4c 76053170 ole32!CProcessActivator::CreateInstance+0x49 [d:\w7rtm\com\ole32\com\objact\actvator.cxx @ 1377]
00137f8c 76052ef4 ole32!ActivationPropertiesIn::DelegateCreateInstance+0x108 [d:\w7rtm\com\ole32\actprops\actprops.cxx @ 1917]
001381ec 76053170 ole32!CClientContextActivator::CreateInstance+0xb0 [d:\w7rtm\com\ole32\com\objact\actvator.cxx @ 685]
0013822c 76053098 ole32!ActivationPropertiesIn::DelegateCreateInstance+0x108 [d:\w7rtm\com\ole32\actprops\actprops.cxx @ 1917]
001389fc 76059e25 ole32!ICoCreateInstanceEx+0x404 [d:\w7rtm\com\ole32\com\objact\objact.cxx @ 1334]
00138a5c 76059d86 ole32!CComActivator::DoCreateInstance+0xd9 [d:\w7rtm\com\ole32\com\objact\immact.hxx @ 343]
00138a80 76059d3f ole32!CoCreateInstanceEx+0x38 [d:\w7rtm\com\ole32\com\objact\actapi.cxx @ 157]
Unable to load image C:\Windows\System32\kunlun.ime, Win32 error 0n2
*** WARNING: Unable to verify timestamp for kunlun.ime
*** ERROR: Module load completed but symbols could not be loaded for kunlun.ime
00138ab0 71a86801 ole32!CoCreateInstance+0x37 [d:\w7rtm\com\ole32\com\objact\actapi.cxx @ 110]
WARNING: Stack unwind information not available. Following frames may be wrong.
00138ad4 71a86722 kunlun+0xf6801
00138b0c 71a8648c kunlun+0xf6722
00138bf0 71a4fb9e kunlun+0xf648c
00138c58 71a51e63 kunlun+0xbfb9e
00138c8c 71a51efc kunlun+0xc1e63
00138cc4 71a51b90 kunlun+0xc1efc
00138d34 71a4fc81 kunlun+0xc1b90
00138d74 762d459a kunlun+0xbfc81
00138d90 762d2900 imm32!CreateInputContext+0x195
00138db8 762d1e8c imm32!InternalImmLockIMC+0xca
00138dc8 762d34ae imm32!ImmLockIMC+0xf
00138dec 750cd9e7 imm32!ImmSetActiveContext+0x62
00138e08 750cadf9 user32!FocusSetIMCContext+0x28
0013905c 750c75b7 user32!ImeSystemHandler+0x31f
00139084 750c75ed user32!ImeWndProcWorker+0x2c9
001390a4 750c62fa user32!ImeWndProcW+0x29
001390d0 750c6d3a user32!InternalCallWinProc+0x23
00139148 750c6de8 user32!UserCallWinProcCheckWow+0x109
001391a4 750c6e44 user32!DispatchClientMessage+0xe0
001391e0 76ea010a user32!__fnDWORD+0x2b
001391f4 00fe7ae0 ntdll!KiUserCallbackDispatcher+0x2e
001392d8 750f10d3 0xfe7ae0
001392fc 750f1125 user32!CreateDialogIndirectParamAorW+0x33
*** ERROR: Module load completed but symbols could not be loaded for notepad++.exe
00139328 00516a73 user32!CreateDialogParamW+0x49
0013934c 750caa3c notepad__+0x116a73
00139400 750c8a5c user32!_CreateWindowEx+0x210
0013943c 0041ee1c user32!CreateWindowExW+0x33
0013a7cc 00584fd4 notepad__+0x1ee1c
0013a7e4 00584fa0 notepad__+0x184fd4
0013a7e8 00400000 notepad__+0x184fa0
0013a7ec 00040d60 notepad__
0013a7f0 00110d3c 0x40d60
0013a7f4 00000000 0x110d3c
</code></pre>

<p>最后的操作在msctf中等待某个事件，msctf 是 Microsoft Text Service；回溯调用栈，看见imm32（Input Method Manager）相关的调用，看来这个无响应的现象与输入法有关系。而 stack 中出现的 kunlun.ime 是必应输入法。</p>

<p>试试把正在使用的必应输入法卸载后重启，系统就正常了。重新安装必应输入法，重启后系统又出现无响应现象。</p>

<p>但比应输入法已经使用了一段时间了，为什么开始没有出现问题呢？回忆了一下，大概是在安装了 <a href="http://synergy-project.org/">Synergy</a> 之后出现的，Synergy共享鼠标键盘，也许有可能与输入法产生冲突。尝试一下，卸载synergy后，即使安装必应，系统也正常。看来可以确认是两者冲突，试了 Synergy 1.4.16/17/18 几个64bit版本都不能与 Bing IME 1.6.98.04 工作。</p>

<p>Ok，对我来说问题解决了，进一步的不再深究。这次学会了使用 WinDbg 查看调用栈的简单操作。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[查找explorer crash原因的工具]]></title>
    <link href="http://aleung.github.io/blog/2010/01/01/The-reason-for-explorer-crash-tools/"/>
    <updated>2010-01-01T06:59:00+08:00</updated>
    <id>http://aleung.github.io/blog/2010/01/01/The-reason-for-explorer-crash-tools</id>
    <content type="html"><![CDATA[<p>不知道装了什么软件之后，只要在文件管理器中点击鼠标右键，Windows Explorer就会崩溃，重新启动依然如是。</p>

<p>找到<a href="http://www.nirsoft.net/">Nir Sofer</a>出品的小工具 ShellExView，这个工具分析注册表，列出所有注册到explorer的shell extension及相关信息，并能够enable/disable选定的extension。找到可疑的extension，将它disable，然后再进行一次右键操作，看看还会不会crash。如此排除法很快就定位出什么软件是罪魁祸首，将它卸载或者将extension disable，问题就解决了。</p>

<p>比较有用的信息是extension type，file extensions，file created time。首先关注文件创建时间，找出最近新增的extension，因为以前正常，最近才出问题，那引起问题通常是新装的软件。不过也不能一概而论，也有可能是以前安装的软件，因为最近的环境更改而出现了问题。另外可以根据extension type和file extensions进行过滤，例如我遇到的问题是右键菜单引发崩溃，那重点关注extension type为Context Menu的那些项。还有，在任何类型文件上按右键菜单都会引发崩溃，所以不大可能是由只针对特定文件类型的extension引发的。虽然系统注册的shell extension很多，例如我这个新装没多久的Vista系统就已经有三百多项，但是大部分都是Microsoft出品的，一般来说还是比较可靠的，只要关注非Microsoft的就可以了，找起问题来还是很快的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在线备份]]></title>
    <link href="http://aleung.github.io/blog/2008/09/15/Online-backup/"/>
    <updated>2008-09-15T18:20:00+08:00</updated>
    <id>http://aleung.github.io/blog/2008/09/15/Online-backup</id>
    <content type="html"><![CDATA[<p>以前介绍过文件同步/备份工具<a href="http://aleung.blogbus.com/logs/5545100.html">Unison</a>，那是一个在两台电脑之间进行文件双向同步的好工具。不过，Unison同步时需要两台电脑同时开机，并且可以通过网络直接通信。我以前用于办公室内两台电脑的同步，非常方便，不过想将办公室和家里的电脑进行同步(备份)，就做不到了。</p>

<p>尝试了网上的在线文件同步/备份/分析工具，这样的网站有好多，我并没有仔细研究比较过，现在用的是<a href="http://syncplicity.com/">Syncplicity</a>，感觉功能不错，速度也可以。</p>

<p>使用相当简便，在要同步的电脑上安装一个client，指定哪些目录需要同步，它就会自动将文件上传服务器，或者从服务器下载，就看哪边的版本更新一点。只要连上网，它就在后台运行，不用费心。如果是要手工执行备份的话，往往会忘记的，自动就没有这个问题。一个帐号可以连接多个client(免费账号限制2个)，相当于星形连接，由服务器分发改变了的文件。备份在服务器上的文件可以通过web界面访问。它的FAQ介绍了它有处理冲突的能力：保留所有不同的版本，让用户自己选择。不过，我没有试过，目前我只是用它来做单向备份。Syncplicity能够与GoogleDoc同步，我没有使用GoogleDoc的需要，也懒得试了。</p>

<p>Syncplicity对免费用户提供2GB空间，允许两台电脑进行同步，当然收费版本的限制会放宽了。免费的服务基本上都够用的，需要备份的是些比较重要又经常变化的文件，如果是备份旧东西，不变的，用刻光盘的方式更合适。</p>

<p>给Syncplicity做了这么多广告，是因为：如果我邀请新用户注册，我可以增加100M空间。所以各位记得填写我的邀请信中的号码啊，呵呵。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to allow remote application setting display to the SUSE linux desktop]]></title>
    <link href="http://aleung.github.io/blog/2008/06/17/How-to-allow-remote-application-setting-display-to-the-SUSE-linux-desktop/"/>
    <updated>2008-06-17T20:59:00+08:00</updated>
    <id>http://aleung.github.io/blog/2008/06/17/How-to-allow-remote-application-setting-display-to-the-SUSE-linux-desktop</id>
    <content type="html"><![CDATA[<ol>
  <li>Allow remote TCP connection to the X server. You need root privilege to config it. </li>
</ol>

<p>Just run gdmsetup. This will open a window with multiple tabs. In the Security tab, disabled the line that says “Deny TCP connections to the X server”. Close the window and then log out of your current X session. You need to restart gdm for this to work.  The easiest way to do that is to go to a console login, login as root, change to run level 3 (just type “init 3”) and then return to run level 5 (“init 5”) to restart gdm. <br />
Ref: <a href="http://www.graphics-muse.org/wp/?p=69">http://www.graphics-muse.org/wp/?p=69</a></p>

<ol>
  <li>Add remote host into X server access control</li>
</ol>

<p>Run xhost <em>remote_host_ip</em></p>

<ol>
  <li>Set DISPLAY environment variable in remote host before execute the application</li>
</ol>

<p>setenv DISPLAY <em>display_host_ip</em>:0.0</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux的cut命令]]></title>
    <link href="http://aleung.github.io/blog/2008/04/15/Linux-cut-/"/>
    <updated>2008-04-15T20:54:00+08:00</updated>
    <id>http://aleung.github.io/blog/2008/04/15/Linux-cut-</id>
    <content type="html"><![CDATA[<p>原来有个这么好用的命令：cut</p>

<p>经常都需要分析一个字符串或者文本文件，根据一些规则提取出其中某部分的内容。以前都是用awk来做，但awk太复杂了，每次都要拿手册查半天。今天才知道原来GNU有个叫cut的命令，就可以做这个事情。</p>

<p>例如，获取当前机器的IP地址：</p>

<pre><code>/sbin/ifconfig | grep 'inet addr' | grep -v '127.0.0.1' | cut -d: -f2 | cut -d' ' -f1
</code></pre>

<p>这个命令在linux和windows的unixutils里都有。</p>
]]></content>
  </entry>
  
</feed>

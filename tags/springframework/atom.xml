<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: SpringFramework | Good good study, day day up]]></title>
  <link href="http://aleung.github.io/blog/tags/springframework/atom.xml" rel="self"/>
  <link href="http://aleung.github.io/blog/"/>
  <updated>2014-06-13T22:17:49+08:00</updated>
  <id>http://aleung.github.io/blog/</id>
  <author>
    <name><![CDATA[Leo Liang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring bean reference injection definition by external configuration]]></title>
    <link href="http://aleung.github.io/blog/2012/07/07/spring-bean-reference-injection-definition-by-external-configuration/"/>
    <updated>2012-07-07T21:38:00+08:00</updated>
    <id>http://aleung.github.io/blog/2012/07/07/spring-bean-reference-injection-definition-by-external-configuration</id>
    <content type="html"><![CDATA[<p>当使用 Spring 作为 IoC framework 的时候，有时会利用 property placeholder 来将bean的注入属性做成可配置化。但是，一般很少会将 reference bean id 也用 property placeholder 代替，有人甚至以为这是不允许的。</p>

<p>利用Spring Framework的property placeholder，将bean依赖关系配置抽离Spring XML文件，就能在产品发布部署后，通过配置选项来选定不同的实现，可用于集成接口、特定业务逻辑打开关闭等。</p>

<p><a href="http://www.oodesign.com/adapter-pattern.html">Adaptor pattern</a> is widely used at the point where our product integrates with external system. Product will provide several adapters to adapt to different external system interface.
We deliver our product in uniform installation package for all customers. A mechanism is required to configure which adapter to be used after system is installed.</p>

<p><a href="http://www.oodesign.com/factory-pattern.html">Factory pattern</a> can be used to create the specific adapter by configuration property. But by this way we need to create factory for each kind of adapters.</p>

<p>Actually Spring Framework already supports it. With property placeholder, it is able to use placeholder in bean reference and resolve the bean name from properties. The bean definition XML file is not allowed to be modified when product is released, because it’s packaged in war/ear. But properties can be modified as long as it’s store outside of the package, e.g. on file system or in configuration management (extend the PropertyPlaceholderConfigurer class).</p>

<p>Here is a sample code snippet:
<div><script src='https://gist.github.com/2934603.js'></script>
<noscript><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;
    default-autowire=&quot;byType&quot;&gt;

    &lt;context:property-placeholder location=&quot;file:bin/leoliang/spring/test1/bean.properties&quot;/&gt;

    &lt;bean id=&quot;fooA&quot; class=&quot;leoliang.spring.test1.FooImplA&quot; /&gt;
    &lt;bean id=&quot;fooB&quot; class=&quot;leoliang.spring.test1.FooImplB&quot; /&gt;
    
    &lt;bean id=&quot;bar&quot; class=&quot;leoliang.spring.test1.Bar&quot;&gt;
        &lt;property name=&quot;foo&quot; ref=&quot;${foo_bean_id}&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dump beans information from live Spring application context]]></title>
    <link href="http://aleung.github.io/blog/2011/11/08/Dump-beans-information-from-live-Spring-application-context/"/>
    <updated>2011-11-08T18:42:00+08:00</updated>
    <id>http://aleung.github.io/blog/2011/11/08/Dump-beans-information-from-live-Spring-application-context</id>
    <content type="html"><![CDATA[<p>To maintain the Spring application context in a large application is not an easy job. There may be dozens of beans, whenever you want to make changes, you have to be very clear on there dependency. After serveral rounds of update, some beans might be orphan, they’re unused any more but you don’t know.</p>

<p>Spring IDE provides bean cross reference view and bean graph view that can help to analysis the bean relationship. But what Spring IDE has is a static view of the beans. In our project the application context is complicated: it scans classpath for all bean definition XML files and load them; application context created in WAR package inherits parent application context which is defines in EJB classpath; some beans are marked with annotation and loaded by <context:component-scan>, rather than define in XML file. I doubt Spring IDE can show the dynamic bean view as it is in runtime. What's more, Spring IDE isn't available at our standard development environment.</context:component-scan></p>

<p>Inspired by a StackOverflow <a href="http://stackoverflow.com/questions/5850639/how-to-keep-track-of-all-the-autowired-stuff-while-using-spring-ioc/5851872#5851872">answer</a>, I created an ApplicationContextDumper. Add it into application context, it will dump all beans and their dependencies in the current context and parent contexts (if any) into log file when the application context initialization finishes. It also lists the beans which aren’t referenced.</p>

<p><div><script src='https://gist.github.com/1347171.js?file=ApplicationContextDumper.java'></script>
<noscript><pre><code>package leoliang.springtest;

import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.support.AbstractRefreshableApplicationContext;

public class ApplicationContextDumper implements ApplicationContextAware {

    private Map&lt;String, Integer&gt; beanReferenceCounter = new HashMap&lt;String, Integer&gt;();
    private StringBuilder outputMessage;

    @Override
    public void setApplicationContext(ApplicationContext context) throws BeansException {
        outputMessage = new StringBuilder();
        beanReferenceCounter.clear();
        outputMessage.append(&quot;--- ApplicationContextDumper begin ---\n&quot;);
        dumpApplicationContext(context);
        dumpBeansWithoutReference();
        outputMessage.append(&quot;--- ApplicationContextDumper end ---\n&quot;);
        System.out.print(outputMessage);
    }

    private void dumpBeansWithoutReference() {
        outputMessage.append(&quot;Beans without reference:\n&quot;);
        for (String bean : beanReferenceCounter.keySet()) {
            if (beanReferenceCounter.get(bean) == 0) {
                outputMessage.append(&quot;  &quot;).append(bean).append('\n');
            }
        }
    }

    private void initBeanReferenceIfNotExist(String beanName) {
        Integer count = beanReferenceCounter.get(beanName);
        if (count == null) {
            beanReferenceCounter.put(beanName, 0);
        }
    }

    private void increaseBeanReference(String beanName) {
        Integer count = beanReferenceCounter.get(beanName);
        if (count == null) {
            count = new Integer(0);
        }
        beanReferenceCounter.put(beanName, ++count);
    }

    private void dumpApplicationContext(ApplicationContext context) {
        // Read context id isn't available. https://jira.springsource.org/browse/SPR-8816
        String appContextInfo = String.format(&quot;ApplicationContext %s : %s&quot;, context.getId(), context.getClass()
                .getName());
        ApplicationContext parent = context.getParent();
        if (parent != null) {
            appContextInfo += String.format(&quot; -&gt; %s&quot;, parent.getId());
        }
        outputMessage.append(appContextInfo).append('\n');

        ConfigurableListableBeanFactory factory = ((AbstractRefreshableApplicationContext) context).getBeanFactory();
        for (String beanName : factory.getBeanDefinitionNames()) {
            if (factory.getBeanDefinition(beanName).isAbstract()) {
                continue;
            }
            initBeanReferenceIfNotExist(beanName);
            Object bean = factory.getBean(beanName);
            outputMessage.append(String.format(&quot;  %s : %s\n&quot;, beanName, bean.getClass().getName()));
            for (String dependency : factory.getDependenciesForBean(beanName)) {
                outputMessage.append(String.format(&quot;    -&gt; %s\n&quot;, dependency));
                increaseBeanReference(dependency);
            }
        }

        if (parent != null) {
            outputMessage.append(&quot;Parent:\n&quot;);
            dumpApplicationContext(parent);
        }
    }

}</code></pre></noscript></div>
</p>

<p>Here is an example. We have two application contexts. Please be noticed that the ApplicationContextDumper has been added into applicationContext.xml.</p>

<p><div><script src='https://gist.github.com/1347171.js?file=applicationContext.xml'></script>
<noscript><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;
    default-lazy-init=&quot;false&quot; default-autowire=&quot;byName&quot;&gt;

    &lt;!-- Enable @Autowired --&gt;
    &lt;context:annotation-config/&gt;
    
    &lt;!-- Load all beans with @Repository --&gt;
    &lt;context:component-scan base-package=&quot;leoliang.springtest&quot;/&gt;

    &lt;bean id=&quot;aNormalBean&quot; class=&quot;leoliang.springtest.NormalBean&quot;&gt;
        &lt;property name=&quot;anotherBean&quot; ref=&quot;anotherBean&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;leoliang.springtest.ApplicationContextDumper&quot; /&gt;
&lt;/beans&gt;</code></pre></noscript></div>

<div><script src='https://gist.github.com/1347171.js?file=parentContext.xml'></script>
<noscript><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;
    &lt;bean id=&quot;abstractBean&quot;  abstract=&quot;true&quot; /&gt;
    &lt;bean id=&quot;anotherBean&quot; class=&quot;leoliang.springtest.AnotherBean&quot; parent=&quot;abstractBean&quot; /&gt;
&lt;/beans&gt;</code></pre></noscript></div>
</p>

<p>parentBeanFactory is the parent of myBeanFactory:</p>

<p><div><script src='https://gist.github.com/1347171.js?file=beanRefContext.xml'></script>
<noscript><pre><code>&lt;beans&gt;
    &lt;bean id=&quot;parentBeanFactory&quot; class=&quot;org.springframework.context.support.ClassPathXmlApplicationContext&quot;&gt;
        &lt;constructor-arg&gt;
            &lt;list&gt;
                &lt;value&gt;classpath:**/parentContext.xml&lt;/value&gt;
            &lt;/list&gt;
        &lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;myBeanFactory&quot; class=&quot;org.springframework.context.support.ClassPathXmlApplicationContext&quot;&gt;
        &lt;constructor-arg&gt;
            &lt;list&gt;
                &lt;value&gt;classpath:**/applicationContext.xml&lt;/value&gt;
            &lt;/list&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg&gt;
            &lt;ref bean=&quot;parentBeanFactory&quot; /&gt;
        &lt;/constructor-arg&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre></noscript></div>
</p>

<p>In main, loads application context from beanRefContext.xml. </p>

<p><div><script src='https://gist.github.com/1347171.js?file=main.java'></script>
<noscript><pre><code>    public static void main(String[] args) {
        String[] paths = { &quot;classpath:**/beanRefContext.xml&quot; };
        new ClassPathXmlApplicationContext(paths);
    }
</code></pre></noscript></div>
</p>

<p>The application context is dumped in log:</p>

<p><div><script src='https://gist.github.com/1347171.js?file=output'></script>
<noscript><pre><code>--- ApplicationContextDumper begin ---
ApplicationContext org.springframework.context.support.ClassPathXmlApplicationContext@e1d5ea : org.springframework.context.support.ClassPathXmlApplicationContext -&gt; parentBeanFactory
  org.springframework.context.annotation.internalConfigurationAnnotationProcessor : org.springframework.context.annotation.ConfigurationClassPostProcessor
  org.springframework.context.annotation.internalAutowiredAnnotationProcessor : org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
  org.springframework.context.annotation.internalRequiredAnnotationProcessor : org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor
  org.springframework.context.annotation.internalCommonAnnotationProcessor : org.springframework.context.annotation.CommonAnnotationBeanPostProcessor
  repositoryBean : leoliang.springtest.RepositoryBean
    -&gt; aNormalBean
  aNormalBean : leoliang.springtest.NormalBean
    -&gt; anotherBean
  leoliang.springtest.ApplicationContextDumper#0 : leoliang.springtest.ApplicationContextDumper
Parent:
ApplicationContext parentBeanFactory : org.springframework.context.support.ClassPathXmlApplicationContext
  anotherBean : leoliang.springtest.AnotherBean
Beans without reference:
  repositoryBean
  org.springframework.context.annotation.internalAutowiredAnnotationProcessor
  org.springframework.context.annotation.internalCommonAnnotationProcessor
  org.springframework.context.annotation.internalConfigurationAnnotationProcessor
  org.springframework.context.annotation.internalRequiredAnnotationProcessor
  leoliang.springtest.ApplicationContextDumper#0
--- ApplicationContextDumper end ---</code></pre></noscript></div>
</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图解：Spring ApplicationContext in enterprise application]]></title>
    <link href="http://aleung.github.io/blog/2010/02/24/Illustration-Spring-ApplicationContext-in-enterprise-application/"/>
    <updated>2010-02-24T21:46:00+08:00</updated>
    <id>http://aleung.github.io/blog/2010/02/24/Illustration-Spring-ApplicationContext-in-enterprise-application</id>
    <content type="html"><![CDATA[<p>在一个比较复杂的enterprise application (EAR)里面，往往有多个war和ejb，如果希望使用Springframework通过IoC方式来管理及装配POJO beans，就要面对如何初始化application context，由谁来初始化，如何让这些war和ejb共享application context等问题。</p>

<p>关于多个war、ejb共享application context的方法，在下面这两篇文章里解释得比较清楚：</p>

<ul>
  <li><a href="http://blog.springsource.com/2007/06/11/using-a-shared-parent-application-context-in-a-multi-war-spring-application/">Using a shared parent application context in a multi-war Spring application</a></li>
  <li><a href="http://springtips.blogspot.com/2007/09/using-shared-context-from-ejbs.html">Using a Shared Context from EJBs</a></li>
</ul>

<p>在这里，我不再详细叙述上面文章中的内容，通过图解的方式希望能让它更易理解，需要对照阅读。</p>

<p>图中的方块、圆圈都表示实例，形状的嵌套表示它们的包含关系。在例子里，缺省值都显式写出来，方便查找。</p>

<p><a href="http://www.flickr.com/photos/leoliang/4384915548/"><img src="http://farm5.static.flickr.com/4037/4384915548_2ec7d610e6_o.png" alt="share-context-1" /></a></p>

<p>先看图中靛蓝色的box，是ContextSingletonBeanFactoryLocator实例，application context的共享是依靠它来实现的：对于每个locatorFactorSelector，在一个classloader的范围内只会存在一个ContextSingletonBeanFactoryLocator的实例。ContextSingletonBeanFactoryLocator内部有一个ApplicationContext（图中的天蓝色box），它的bean是由locatorFactorSelector所指向的xml文件所定义的。例如locatorFactorSelector为classpath*:beanRefContext.xml，就会寻找classpath中所有的beanRefContext.xml文件并根据它们去创建内部ApplicationContext。这个内部ApplicationContext只是其它ApplicationContext的容器，不存放application的bean。一个beanRefContext.xml文件应该像下面那样，里面是一个ApplicationContext，它才是真正的业务bean的容器。如果需要可以设置它的parent context。如果有多个beanRefContext.xml文件，就会创建多个ApplicationContext，它们通过id来标识。</p>

<p><code>xml beanRefContext.xml
    &lt;beans&gt;
        &lt;bean id="a" class="org.springframework.context.support.ClassPathXmlApplicationContext"&gt;
            &lt;constructor-arg&gt;
                &lt;list&gt;
                    &lt;value&gt;context_a.xml&lt;/value&gt;
                &lt;/list&gt;
            &lt;/constructor-arg&gt;
            &lt;constructor-arg&gt;
                &lt;ref bean="b" /&gt;
            &lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
</code> </p>

<p>EJB应该在onCreate()过程中通过下面的代码来获得application context，需要通过factoryKey（例子里是”a”）来指定具体是哪个context：</p>

<p><code>java
beanFactory= ContextSingletonBeanFactoryLocator.getInstance("classpath*:beanRefContext.xml").useBeanFactory("a").getFactory();
</code></p>

<p>在war里是依靠ContextLoaderListener来启动ApplicationContext的。在web.xml里加入：</p>

<p><code>xml web.xml    
        &lt;listener&gt;
            &lt;listener-class&gt;
                org.springframework.web.context.ContextLoaderListener
            &lt;/listener-class&gt;
        &lt;/listener&gt;
</code></p>

<p>这个application context包含的是/WEB-INF/applicationContext.xml中定义的beans。在Servlet中通过下面的代码可以获得这个context：</p>

<p><code>java
beanFactory = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());
</code></p>

<p>但这样创建出来的是一个独立的application context，仅仅在war内部可以访问，无法做到多个war和ejb之间共享。</p>

<p>要实现共享，就要在web.xml中再加入：</p>

<p><code>xml web.xml
        &lt;context-param&gt;
            &lt;param-name&gt;parentContextKey&lt;/param-name&gt;
            &lt;param-value&gt;b&lt;/param-value&gt;
        &lt;/context-param&gt;
        &lt;context-param&gt;
            &lt;param-name&gt;locatorFactorySelector&lt;/param-name&gt;
            &lt;param-value&gt;classpath*:beanRefContext.xml&lt;/param-value&gt; &lt;!-- this is the default value --&gt;
        &lt;/context-param&gt;
</code></p>

<p>这样，当ContextLoaderListener创建war的application context时，会根据locatorFactorySelector去取相应的ContextSingletonBeanFactoryLocator实例，并且从locator中根据parentContextKey拿到具体的context，将这个context作为war的application context的parent。在图中，war 1的servlet可以访问到key为’b’的context，因为它是当前context的parent。</p>

<p>最后的效果就是：哪个war或者ejb先初始化，它就会去初始化ContextSingletonBeanFactoryLocator实例，由于是singleton，只会有一个实例存在，所有的war和ejb都从这个locator里面拿到具体存放业务bean的context，实现了context的共享。</p>

<p>在这里需要留意的是classloader，必须很清楚的知道哪些类是由哪个层次的classloader加载的：所有共享的bean，以及相关的spring jar都必须由EJB classloader加载。关于EAR的classloader及层次关系请参看 <a href="http://good-good-study.appspot.com/blog/posts/4218">WebLogic的classloading</a>。</p>

<p>在实际应用中，往往不需要对application context作隔离，整个ear里面所有ejb、war共享一个application context是最简便的。这时war里不需要定义任何context和context loader，与EJB一样直接使用ContextSingletonBeanFactoryLocator就可以获取到context。</p>

<p><code>java
beanFactory= ContextSingletonBeanFactoryLocator.getInstance("classpath*:beanRefContext.xml").useBeanFactory("share-context").getFactory();
</code></p>

<p><a href="http://www.flickr.com/photos/leoliang/5370082919/"><img src="http://farm6.static.flickr.com/5245/5370082919_6dfc7f7b1d_z.jpg" alt="sping_shared_context" /></a></p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: SpringFramework | Good good study, day day up]]></title>
  <link href="http://aleung.github.io/blog/tags/springframework/atom.xml" rel="self"/>
  <link href="http://aleung.github.io/blog/"/>
  <updated>2014-03-15T13:59:47+08:00</updated>
  <id>http://aleung.github.io/blog/</id>
  <author>
    <name><![CDATA[Leo Liang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring bean reference injection definition by external configuration]]></title>
    <link href="http://aleung.github.io/blog/2012/07/07/spring-bean-reference-injection-definition-by-external-configuration/"/>
    <updated>2012-07-07T21:38:00+08:00</updated>
    <id>http://aleung.github.io/blog/2012/07/07/spring-bean-reference-injection-definition-by-external-configuration</id>
    <content type="html"><![CDATA[<p>当使用 Spring 作为 IoC framework 的时候，有时会利用 property placeholder 来将bean的注入属性做成可配置化。但是，一般很少会将 reference bean id 也用 property placeholder 代替，有人甚至以为这是不允许的。</p>

<p>利用Spring Framework的property placeholder，将bean依赖关系配置抽离Spring XML文件，就能在产品发布部署后，通过配置选项来选定不同的实现，可用于集成接口、特定业务逻辑打开关闭等。</p>

<p><a href="http://www.oodesign.com/adapter-pattern.html">Adaptor pattern</a> is widely used at the point where our product integrates with external system. Product will provide several adapters to adapt to different external system interface.
We deliver our product in uniform installation package for all customers. A mechanism is required to configure which adapter to be used after system is installed.</p>

<p><a href="http://www.oodesign.com/factory-pattern.html">Factory pattern</a> can be used to create the specific adapter by configuration property. But by this way we need to create factory for each kind of adapters.</p>

<p>Actually Spring Framework already supports it. With property placeholder, it is able to use placeholder in bean reference and resolve the bean name from properties. The bean definition XML file is not allowed to be modified when product is released, because it’s packaged in war/ear. But properties can be modified as long as it’s store outside of the package, e.g. on file system or in configuration management (extend the PropertyPlaceholderConfigurer class).</p>

<p>Here is a sample code snippet:
{% gist https://gist.github.com/2934603 %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dump beans information from live Spring application context]]></title>
    <link href="http://aleung.github.io/blog/2011/11/08/Dump-beans-information-from-live-Spring-application-context/"/>
    <updated>2011-11-08T18:42:00+08:00</updated>
    <id>http://aleung.github.io/blog/2011/11/08/Dump-beans-information-from-live-Spring-application-context</id>
    <content type="html"><![CDATA[<p>To maintain the Spring application context in a large application is not an easy job. There may be dozens of beans, whenever you want to make changes, you have to be very clear on there dependency. After serveral rounds of update, some beans might be orphan, they’re unused any more but you don’t know.</p>

<p>Spring IDE provides bean cross reference view and bean graph view that can help to analysis the bean relationship. But what Spring IDE has is a static view of the beans. In our project the application context is complicated: it scans classpath for all bean definition XML files and load them; application context created in WAR package inherits parent application context which is defines in EJB classpath; some beans are marked with annotation and loaded by <context:component-scan>, rather than define in XML file. I doubt Spring IDE can show the dynamic bean view as it is in runtime. What's more, Spring IDE isn't available at our standard development environment.</context:component-scan></p>

<p>Inspired by a StackOverflow <a href="http://stackoverflow.com/questions/5850639/how-to-keep-track-of-all-the-autowired-stuff-while-using-spring-ioc/5851872#5851872">answer</a>, I created an ApplicationContextDumper. Add it into application context, it will dump all beans and their dependencies in the current context and parent contexts (if any) into log file when the application context initialization finishes. It also lists the beans which aren’t referenced.</p>

<p>{% gist 1347171 ApplicationContextDumper.java %}</p>

<p>Here is an example. We have two application contexts. Please be noticed that the ApplicationContextDumper has been added into applicationContext.xml.</p>

<p>{% gist 1347171 applicationContext.xml %}
{% gist 1347171 parentContext.xml %}</p>

<p>parentBeanFactory is the parent of myBeanFactory:</p>

<p>{% gist 1347171 beanRefContext.xml %}</p>

<p>In main, loads application context from beanRefContext.xml. </p>

<p>{% gist 1347171 main.java %}</p>

<p>The application context is dumped in log:</p>

<p>{% gist 1347171 output %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图解：Spring ApplicationContext in enterprise application]]></title>
    <link href="http://aleung.github.io/blog/2010/02/24/Illustration-Spring-ApplicationContext-in-enterprise-application/"/>
    <updated>2010-02-24T21:46:00+08:00</updated>
    <id>http://aleung.github.io/blog/2010/02/24/Illustration-Spring-ApplicationContext-in-enterprise-application</id>
    <content type="html"><![CDATA[<p>在一个比较复杂的enterprise application (EAR)里面，往往有多个war和ejb，如果希望使用Springframework通过IoC方式来管理及装配POJO beans，就要面对如何初始化application context，由谁来初始化，如何让这些war和ejb共享application context等问题。</p>

<p>关于多个war、ejb共享application context的方法，在下面这两篇文章里解释得比较清楚：</p>

<ul>
  <li><a href="http://blog.springsource.com/2007/06/11/using-a-shared-parent-application-context-in-a-multi-war-spring-application/">Using a shared parent application context in a multi-war Spring application</a></li>
  <li><a href="http://springtips.blogspot.com/2007/09/using-shared-context-from-ejbs.html">Using a Shared Context from EJBs</a></li>
</ul>

<p>在这里，我不再详细叙述上面文章中的内容，通过图解的方式希望能让它更易理解，需要对照阅读。</p>

<p>图中的方块、圆圈都表示实例，形状的嵌套表示它们的包含关系。在例子里，缺省值都显式写出来，方便查找。</p>

<p><a href="http://www.flickr.com/photos/leoliang/4384915548/"><img src="http://farm5.static.flickr.com/4037/4384915548_2ec7d610e6_o.png" alt="share-context-1" /></a></p>

<p>先看图中靛蓝色的box，是ContextSingletonBeanFactoryLocator实例，application context的共享是依靠它来实现的：对于每个locatorFactorSelector，在一个classloader的范围内只会存在一个ContextSingletonBeanFactoryLocator的实例。ContextSingletonBeanFactoryLocator内部有一个ApplicationContext（图中的天蓝色box），它的bean是由locatorFactorSelector所指向的xml文件所定义的。例如locatorFactorSelector为classpath*:beanRefContext.xml，就会寻找classpath中所有的beanRefContext.xml文件并根据它们去创建内部ApplicationContext。这个内部ApplicationContext只是其它ApplicationContext的容器，不存放application的bean。一个beanRefContext.xml文件应该像下面那样，里面是一个ApplicationContext，它才是真正的业务bean的容器。如果需要可以设置它的parent context。如果有多个beanRefContext.xml文件，就会创建多个ApplicationContext，它们通过id来标识。</p>

<p><code>xml beanRefContext.xml
    &lt;beans&gt;
        &lt;bean id="a" class="org.springframework.context.support.ClassPathXmlApplicationContext"&gt;
            &lt;constructor-arg&gt;
                &lt;list&gt;
                    &lt;value&gt;context_a.xml&lt;/value&gt;
                &lt;/list&gt;
            &lt;/constructor-arg&gt;
            &lt;constructor-arg&gt;
                &lt;ref bean="b" /&gt;
            &lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
</code> </p>

<p>EJB应该在onCreate()过程中通过下面的代码来获得application context，需要通过factoryKey（例子里是”a”）来指定具体是哪个context：</p>

<p><code>java
beanFactory= ContextSingletonBeanFactoryLocator.getInstance("classpath*:beanRefContext.xml").useBeanFactory("a").getFactory();
</code></p>

<p>在war里是依靠ContextLoaderListener来启动ApplicationContext的。在web.xml里加入：</p>

<p><code>xml web.xml    
        &lt;listener&gt;
            &lt;listener-class&gt;
                org.springframework.web.context.ContextLoaderListener
            &lt;/listener-class&gt;
        &lt;/listener&gt;
</code></p>

<p>这个application context包含的是/WEB-INF/applicationContext.xml中定义的beans。在Servlet中通过下面的代码可以获得这个context：</p>

<p><code>java
beanFactory = WebApplicationContextUtils.getWebApplicationContext(this.getServletContext());
</code></p>

<p>但这样创建出来的是一个独立的application context，仅仅在war内部可以访问，无法做到多个war和ejb之间共享。</p>

<p>要实现共享，就要在web.xml中再加入：</p>

<p><code>xml web.xml
        &lt;context-param&gt;
            &lt;param-name&gt;parentContextKey&lt;/param-name&gt;
            &lt;param-value&gt;b&lt;/param-value&gt;
        &lt;/context-param&gt;
        &lt;context-param&gt;
            &lt;param-name&gt;locatorFactorySelector&lt;/param-name&gt;
            &lt;param-value&gt;classpath*:beanRefContext.xml&lt;/param-value&gt; &lt;!-- this is the default value --&gt;
        &lt;/context-param&gt;
</code></p>

<p>这样，当ContextLoaderListener创建war的application context时，会根据locatorFactorySelector去取相应的ContextSingletonBeanFactoryLocator实例，并且从locator中根据parentContextKey拿到具体的context，将这个context作为war的application context的parent。在图中，war 1的servlet可以访问到key为’b’的context，因为它是当前context的parent。</p>

<p>最后的效果就是：哪个war或者ejb先初始化，它就会去初始化ContextSingletonBeanFactoryLocator实例，由于是singleton，只会有一个实例存在，所有的war和ejb都从这个locator里面拿到具体存放业务bean的context，实现了context的共享。</p>

<p>在这里需要留意的是classloader，必须很清楚的知道哪些类是由哪个层次的classloader加载的：所有共享的bean，以及相关的spring jar都必须由EJB classloader加载。关于EAR的classloader及层次关系请参看 <a href="http://good-good-study.appspot.com/blog/posts/4218">WebLogic的classloading</a>。</p>

<p>在实际应用中，往往不需要对application context作隔离，整个ear里面所有ejb、war共享一个application context是最简便的。这时war里不需要定义任何context和context loader，与EJB一样直接使用ContextSingletonBeanFactoryLocator就可以获取到context。</p>

<p><code>java
beanFactory= ContextSingletonBeanFactoryLocator.getInstance("classpath*:beanRefContext.xml").useBeanFactory("share-context").getFactory();
</code></p>

<p><a href="http://www.flickr.com/photos/leoliang/5370082919/"><img src="http://farm6.static.flickr.com/5245/5370082919_6dfc7f7b1d_z.jpg" alt="sping_shared_context" /></a></p>
]]></content>
  </entry>
  
</feed>

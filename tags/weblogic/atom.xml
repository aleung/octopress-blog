<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: WebLogic | Good good study, day day up]]></title>
  <link href="http://aleung.github.io/blog/tags/weblogic/atom.xml" rel="self"/>
  <link href="http://aleung.github.io/blog/"/>
  <updated>2014-09-17T00:12:55+08:00</updated>
  <id>http://aleung.github.io/blog/</id>
  <author>
    <name><![CDATA[Leo Liang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Understanding WebLogic WorkManager]]></title>
    <link href="http://aleung.github.io/blog/2012/08/10/understanding-weblogic-workmanager/"/>
    <updated>2012-08-10T22:54:00+08:00</updated>
    <id>http://aleung.github.io/blog/2012/08/10/understanding-weblogic-workmanager</id>
    <content type="html"><![CDATA[<p>Since WebLogic Server 9.0, new concepts for workload management is introduced. WorkManager replaces execute queue as defined in earlier releases.</p>

<p>All WorkManagers share a common thread pool and a priority-based queue. The size of the thread pool is determined automatically by the kernel and resized as needed.  Priority of the requests is dynamic and computed internally to meet the stated goals. </p>

<p>The thread pool is so-called self-tunning. It monitors the overall throughput every two seconds and uses the collected data to determine if thread count needs to change. Present thread count, the measured throughput, and the past history is taken into account by the algorithm to determine if the thread count needs to increase or decrease, and new threads are automatically added to the pool or removed, as needed.</p>

<p>It’s no longer have to (and is unable to) configure thread counts on a WorkManager nor the common thread pool. However, it’s possible to affect how server prioritizes work and allocates threads by parameters defined in WorkManager. Each WorkManager can contain following types of components:</p>

<ul>
  <li>Request class 
    <ul>
      <li>Fair-share</li>
      <li>Response-time goal</li>
      <li>Context based</li>
    </ul>
  </li>
  <li>Constraints
    <ul>
      <li>Minimum threads constraint</li>
      <li>Maximum threads constraint</li>
      <li>Capacity</li>
    </ul>
  </li>
</ul>

<p>Request class affects how requests are prioritized. Fair-share request class changes thread usage weight of a WorkManage, which is by default 50. Response-time goal request class specifies the response-time goal in milliseconds. Context-based request class is a compound request class that provides a mapping between the request context and the above two request classes. With context-based request class, it’s possible to specify different request classes for the same servlet invocation depending on the user associated with the invocation.</p>

<p>A constraint defines minimum and maximum numbers of threads allocated to execute requests and the total number of requests that can be queued or executing before WebLogic Server begins rejecting requests. Constraint is referenced in WorkManager by constraint name. So a constraint can be shared by several WorkManagers and set the common limit.</p>

<p>Minimum threads constraint makes sure that during periods of high workloads, there would still be a certain number of threads from the self-tuning thread pool available to process work requests for all work managers that reference the minimum threads constraint. Using the minimum threads constraint could result in some side-effects. Users should consider adding a minimum threads constraint to a work manager configuration when it is critical that progress must be made for an application even when the WLS server is under very heavy load, such as work that would have resulted in server-to-server deadlock if not being processed promptly. It is not to be used as a mean of prioritizing workload among different work managers. </p>

<p>The maximum threads constraint limits the number of threads in the self-tuning thread pool that can be used for executing work for all work managers that references the same constraint. The maximum threads constraint is not designed as a mean to prioritize workloads among different work managers. It is most useful when there are other known limitations where a hard upper limit should be put on the number of threads that should be assigned for processing work requests, and that allocating more threads for processing the workload would not increase the overall throughput.</p>

<p>A typical use case of maximum threads constraint is to take a data source connection pool size as the max constraint.</p>

<pre><code>&lt;max-threads-constraint&gt;
  &lt;name&gt;MyConstraint&lt;/name&gt;
  &lt;pool-name&gt;MyDataSource&lt;/pool-name&gt;
&lt;/max-threads-constraint&gt;
</code></pre>

<p>The capacity constraint defines the maximum number of requests that can be queued (waiting for thread) or are executing. Overload action, e.g. refuse with HTTP response code 503, is taken after the capacity is reached. </p>

<p>I draw a picture to show the threadpool and queue. Requests dispatched with different WorkManager are in different color.</p>

<p><img src="/attachments/2012/8/workmanager.jpg" alt="" /></p>

<ul>
  <li>Self-tuning thread pool thread allocation ratio amoung WorkManagers is affected by request class. </li>
  <li>Minimum threads constraint limits: never queue request, unless <code>executing &gt;= min-threads-constraint.count</code></li>
  <li>Maximum threads constraint limits: <code>executing &lt;= max-threads-constraint.count</code></li>
  <li>capacity contraint limits: <code>executing + queued &lt;= capacity.count</code></li>
</ul>

<p>WorkManager can be created for a specific application or module (ejb/war), which is called application-scoped WorkManager. If there is no special requirement on individual application or module, you can create global Work Managers that are available to all applications and modules. An application uses a globally-defined Work Manager as a template. Each application creates its own instance, this means that each application has its own default WorkManager that is not shared with other applications. WebLogic Server provides a built-in default Work Manager which may be sufficient for most application requirements.</p>

<p>Reference:</p>

<ul>
  <li><a href="http://www.oracle.com/technetwork/articles/entarch/workload-management-088692.html">Workload Management in WebLogic Server 9.0</a></li>
  <li><a href="https://blogs.oracle.com/WebLogicServer/entry/threads_constraints_in_work_ma">Threads Constraints in Work Managers</a></li>
  <li><a href="http://docs.oracle.com/cd/E15051_01/wls/docs103/config_wls/self_tuned.html">Using Work Managers to Optimize Scheduled Work</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Diagram of WebLogic MBean navigation]]></title>
    <link href="http://aleung.github.io/blog/2011/03/21/Diagram-of-WebLogic-MBean-navigation/"/>
    <updated>2011-03-21T18:37:00+08:00</updated>
    <id>http://aleung.github.io/blog/2011/03/21/Diagram-of-WebLogic-MBean-navigation</id>
    <content type="html"><![CDATA[<p>It isn’t a full diagram that presents all WebLogic MBeans. Only the MBeans I’m interesting in are shown.</p>

<p><a href="http://www.flickr.com/photos/leoliang/5546496754/"><img src="http://farm6.static.flickr.com/5056/5546496754_181f58ec69_b.jpg" alt="WeblogicMBean" /></a></p>

<p>Reference:<a href="http://download.oracle.com/docs/cd/E15051_01/wls/docs103/wlsmbeanref/core/index.html">The WebLogic Server® MBean Reference</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebLogic在非Resource Adapter里直接使用JCA WorkManager的失败尝试]]></title>
    <link href="http://aleung.github.io/blog/2010/11/02/WebLogic-Resource-Adapter-JCA-WorkManager-/"/>
    <updated>2010-11-02T05:43:00+08:00</updated>
    <id>http://aleung.github.io/blog/2010/11/02/WebLogic-Resource-Adapter-JCA-WorkManager-</id>
    <content type="html"><![CDATA[<p>JCA 1.5 规范定义了WorkManager API，能方便的进行任务的(多线程)并行处理。按照JCA规范的原意，WorkManager是仅提供给Resource Adapter使用的，容器会提供WorkManager实例并通过BootstrapContext注入到adapter中。可是，有时在其他场合，例如EJB、Servlet中，也希望能将请求拆分，使用WorkManager并行处理，但JEE规范中并没有提供这样的机制。</p>

<p>WebLogic提供了CommonJ WorkManager API，可用于任意应用中，但这个API不在JEE规范之中，因此GlassFish是不支持的。而且，使用WebLogic CommonJ WorkManager时需要在ejb-jar.xml中加入一个类型为commonj.work.WorkManager的resource reference，这样同一个ejb包就不能在不同application server间通用了，因此我还是希望能找到一种通用的方法。</p>

<p>SpringFramework的org.springframework.jca.work包为GlassFish和JBoss提供了在Resource Adapter外部使用JCA 1.5 WorkManager的简便方法。看了for GlassFish的源代码，发现它其实是调用了GlassFish内部的factory去直接创建WorkManager，那么对GlassFish是否也可以这样做呢？</p>

<p>反编译WebLogic的jar包，发现commonj WorkManager和connector WorkManager实际上都是delegate到一个weblogic.work.WorkManager实现的，也就是说在WebLogic里，CommonJ和JCA的WorkManager的底层实现其实都是同样的。接下来找到了weblogic.work.WorkManagerFactory，它有find和findOrCreate方法可返回weblogic.work.WorkManager实例，也许就是可以拿到weblogic-ejb-jar.xml里面定义的weblogic WorkManager。拿到了内部的weblogic.work.WorkManager实例后，再调用weblogic.connector.work.WorkManager的create方法，将这个内部WorkManger包裹到JCA WorkManager中，那么我们的应用就可以使用这个JCA WorkManager了，通过Spring的WorkManagerTaskExecutor来很方便的调度任务，上层的逻辑就可以做到与应用服务器无关。看起来很美。</p>

<p><a href="http://www.flickr.com/photos/leoliang/5137622842/"><img src="http://farm2.static.flickr.com/1208/5137622842_a9b4e5fda8_b.jpg" alt="WLS-WorkManager" /></a></p>

<p>可是结果是残酷的。写了一个测试程序，结果是通过这个WorkManagerFactory可以成功的获取到weblogic.work.WorkManager实例，也能够创建出包裹的JCA WorkManager，可是真正要使用它来执行work时，它很坚定的拒绝了，抛出异常信息：Attempt to create Work outside the context of the Connector container。</p>

<p>查看代码，发现weblogic.connector.work.WorkManager及WorkImpl内部会寻找相应的RAInstanceManager，并且WorkImpl需要用到rarClassloader，看来它设计上还是与resource adapter相关的。一涉及到classloader，我无心恋战了，算了，就此打住。</p>

<p>P.S. 既然说到WorkManager，就推荐一下我的同事写的相关的一篇blog：<a href="http://www.javaeye.com/topic/623825">application server 下的任务异步/并行执行方案</a></p>

<p>P.P.S. 我后来采用的解决方案是让build system可以根据需要为不同的 target application server 选择不同的 deployment descriptor 来build相应的artifacts。</p>

<p>P.P.P.S. 回头再读一下，发现文章里中文英文混杂得很厉害。没办法了，那些专业术语都是看惯英文了，用中文翻译了反而别扭。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WebLogic的classloading]]></title>
    <link href="http://aleung.github.io/blog/2009/09/27/WebLogic-classloading/"/>
    <updated>2009-09-27T07:23:00+08:00</updated>
    <id>http://aleung.github.io/blog/2009/09/27/WebLogic-classloading</id>
    <content type="html"><![CDATA[<p>一直对classloading的了解不是很清晰，每次遇到涉及WebLogic的classpath设置、classloading问题debug时都要去网上搜索资料。现在把资料整理下来。</p>

<p><a href="http://www.flickr.com/photos/leoliang/4379354938/"><img src="http://farm3.static.flickr.com/2682/4379354938_dc7cd5f47e_o.png" alt="wls_classloading" /></a></p>

<h3 id="section"></h3>

<h3 id="classloader">各层级classloader加载的类的范围</h3>

<ul>
  <li>Bootstrap classloader
    <ul>
      <li>Core Java libraries (<jre>/lib)</jre></li>
    </ul>
  </li>
  <li>Extension classloader
    <ul>
      <li>JRE extensions directory (<jre>/lib/ext)</jre></li>
    </ul>
  </li>
  <li>WebLogic Server system classloader
    <ul>
      <li>Classpath</li>
      <li>
        <domain>/lib

</domain>
      </li>
    </ul>
  </li>
  <li>Filtering classloader
    <ul>
      <li>nothing</li>
    </ul>
  </li>
  <li>Application classloader
    <ul>
      <li>EJB JARs</li>
      <li>APP-INF/lib</li>
      <li>APP-INF/classes</li>
      <li>Manifest Class-Path in EJB JARs</li>
    </ul>
  </li>
  <li>Web application classloader
    <ul>
      <li>WAR</li>
      <li>Manifest Class-Path in WAR</li>
    </ul>
  </li>
</ul>

<h3 id="section-1">类加载的优先级</h3>

<p>每个classloader在要加载一个class之前都会先请求它的上层classloader，如此逐级传递。因此效果就是越上层的classloader优先级越高，一个class如果在上层classloader能加载到，就不会让下面的classloader加载。</p>

<p>但是web application classloader是个特例，通过在weblogic.xml中配置<prefer-web-inf-classes>，可以让web application classloader优先在自己war范围内加载类，找不到的类才会请求上层classloader。</prefer-web-inf-classes></p>

<p>Filtering classloader是个特殊的classloader，它并不会加载任何类，而是起到控制类加载优先级的作用。在weblogic-application.xml中配置<prefer-application-packages>，可以限制对于指定的类不再向上层classloader请求，也就是限制在EAR的范围之内加载。</prefer-application-packages></p>

<h3 id="section-2">其他</h3>

<p>以上仅仅描述了缺省情况下classloading的行为。WebLogic对于一个application (EAR)内的classloader的层次结构是可以自定义的。Shared library和optional package，也会影响到classloading。另外，resource adapter (RAR)也有独立的classloader。还有其他的一些细节，需要查阅<a href="http://download.oracle.com/docs/cd/E13222_01/wls/docs100/programming/classloading.html">Understanding WebLogic Server Application Classloading</a>。</p>
]]></content>
  </entry>
  
</feed>

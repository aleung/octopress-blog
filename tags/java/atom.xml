<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Java | Good good study, day day up]]></title>
  <link href="http://aleung.github.io/blog/tags/java/atom.xml" rel="self"/>
  <link href="http://aleung.github.io/blog/"/>
  <updated>2015-10-06T01:05:58+08:00</updated>
  <id>http://aleung.github.io/blog/</id>
  <author>
    <name><![CDATA[Leo Liang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java的volatile关键字的作用]]></title>
    <link href="http://aleung.github.io/blog/2012/09/17/Java-volatile-/"/>
    <updated>2012-09-17T00:00:00+08:00</updated>
    <id>http://aleung.github.io/blog/2012/09/17/Java-volatile-</id>
    <content type="html"><![CDATA[<ul>
  <li>Initial: 2008-12-04</li>
  <li>Updated: 2012-9-17</li>
</ul>

<p>Java内存模型中，有主内存和每个线程各自的工作内存，虚拟机和硬件可能会让线程工作内存优先存储于寄存器和高速缓存中，以提高性能。</p>

<p>所有变量都存储在主内存中，线程工作内存中保存了此线程使用到的变量的副本。工作内存在线程之间是隔离的，对其他线程不可见。线程对变量的所有操作都必须在工作内存中进行，修改后的变量副本要写回主内存。这样就会出现同一个变量在某个瞬间，在一个线程的工作内存中的值可能与另外一个线程工作内存中的值，或者主内存中的值不一致的情况。</p>

<p>一个变量声明为volatile，就意味着这个变量被修改时其他所有使用到此变量的线程都立即能见到变化（称之为可见性）。具体是在每次使用前都要先刷新，以保证别的线程中的修改已经反映到本线程工作内存中，因此可以保证执行时的一致性。以下例子展现了volatile的作用：</p>

<p>``` java  <br />
    public class StoppableTask extends Thread {<br />
      private volatile boolean pleaseStop;  </p>

<pre><code>  public void run() {  
    while (!pleaseStop) {  
      // do some stuff...  
    }  
  }  
  
  public void tellMeToStop() {  
    pleaseStop = true;  
  }  
} ```
</code></pre>

<p>假如pleaseStop没有被声明为volatile，线程执行run的时候检查的是自己的副本，就不能及时得知其他线程已经调用tellMeToStop()修改了pleaseStop的值。</p>

<p>Volatile一般情况下并不能代替sychronized，因为volatile不能保证操作的原子性，即使只是i++，实际上也是由多个原子操作组成：read i; inc; write i，假如多个线程同时执行i++，依然可能由于不同线程交替执行而出现写入脏数据的情况。也就是说，如果对变量值的修改需要依赖于变量之前的值，那么volatile不能保证一致性，需要用sychronized，或者使用atomic类型(java.util.concurrent.atomic.*)；而上面的代码例子是可以使用volatile的典型场景。</p>

<p>Volatile的另外一个作用是禁止指令的重排序优化。在一般情况下，Java执行语句的顺序可能会因为自动优化而修改，例如下面的例子，initialized的赋值有可能在doInitialize()之前就执行了，线程B就有可能不会正确的等待初始化完成。</p>

<p><code>java
boolean initialized = false;
</code></p>

<p><code>java
// run in one thread
doInitialize();
initialized = true;
</code></p>

<p><code>java
// run in another thread
while (!initialized) {
  sleep();
}
</code></p>

<p>如果将initialized声明为volatile，就能保证它的执行顺序不会被改变（但JavaSE 5之前的版本依然会有问题）。</p>

<p>以前在讲述Java与C++区别的时候，有个著名的例子是double-checked locking在Java中不能使用，就是执行顺序优化造成的问题。但自JavaSE 5起，配合volatile的使用是可以实现double-checked locking的。</p>

<p>Reference：</p>

<ul>
  <li><a href="http://www.javamex.com/tutorials/synchronization_volatile.shtml">http://www.javamex.com/tutorials/synchronization_volatile.shtml</a></li>
  <li><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html">http://www.ibm.com/developerworks/cn/java/j-jtp06197.html</a></li>
  <li><a href="http://book.douban.com/subject/6522893/">深入理解Java虚拟机</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java“错误模式”]]></title>
    <link href="http://aleung.github.io/blog/2003/08/20/Java-/"/>
    <updated>2003-08-20T19:01:00+08:00</updated>
    <id>http://aleung.github.io/blog/2003/08/20/Java-</id>
    <content type="html"><![CDATA[<p>《诊断 Java 代码》这组文章提到了很多种“错误模式”，有时间值得看看。<br />
<a href="http://www.ibm.com/developerWorks/cn/java/j-diag/index.shtml">http://www.ibm.com/developerWorks/cn/java/j-diag/index.shtml</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java字符转换问题]]></title>
    <link href="http://aleung.github.io/blog/2003/08/18/Java-/"/>
    <updated>2003-08-18T22:57:00+08:00</updated>
    <id>http://aleung.github.io/blog/2003/08/18/Java-</id>
    <content type="html"><![CDATA[<p>字符编码问题一直都是令人头痛，查阅资料，写下了《java 字符转换问题的学习笔记》。</p>

<h3 id="section">什么是字节流与字符流的转换? 什么时候会做转换?</h3>

<p>字符就是char类型, 是双字节的, 用unicode, 一个char就是实际上的一个字符；字节就是byte类型, 是单字节的，实际的字符串根据编码不同，用单字节或者双字节来表示。<br />
常用的String类型核心就是char[]，String.length()就是char[]数组的大小，因此当encoding没有转换错误时，String长度是字符的个数，不管是中文还是英文。做字符处理的时候也从来不会出现截断半个字符的问题。<br />
Java内部都是用char的，但是很多时候做输入输出就要用byte stream，例如文件、数据库、网络。<br />
当数据要从char变为byte，或者byte变成char时，就要做转换。<br />
同样的内容，用不同的编码方式(encoding)，byte stream是不同的，转换的时候需要指定使用的encoding。<br />
JVM的file.encoding属性确定了JVM的缺省的编码/解码方式：从而影响应用中所有字节流==&gt;字符流的解码方式 字符流==&gt;字节流的编码方式。在不同OS平台上，这是由locale决定的，缺省encoding在中文平台为GBK，英文平台为8859_1。  </p>

<h3 id="java-io">Java I/O</h3>
<p>Reader和Writer核心是char，InputStream和OutputStream核心是byte。<br />
专门有bridge类做Reader/Writer与InputStream/OutputStream的转换：InputStreamReader/OutputStreamWriter。  </p>

<h3 id="utf8unicode">UTF8与unicode</h3>
<p>准确的说，UTF8不是unicode，它也只是一种编码方式，不过它的编码空间可以容纳unicode的所有字符。因此UTF8是一种很适合于存储unicode的外码。UTF8是变长编码，中文3字节。  </p>

<h3 id="section-1">什么地方会发生转换？</h3>

<ul>
  <li>
    <p>从数据库到java程序 byte——〉char  </p>
  </li>
  <li>
    <p>从java程序到数据库 char——〉byte  </p>
  </li>
  <li>
    <p>从文件到java程序 byte——〉char  </p>
  </li>
  <li>
    <p>从java程序到文件 char——〉byte  </p>
  </li>
  <li>
    <p>从java程序到页面显示 char——〉byte  </p>
  </li>
  <li>
    <p>从页面form提交数据到java程序 byte——〉char  </p>
  </li>
  <li>
    <p>从流到java程序 byte——〉char  </p>
  </li>
  <li>
    <p>从java程序到流 char——〉byte  </p>
  </li>
</ul>

<h3 id="section-2">源程序中的字符串</h3>
<p>最早的字节流解码过程从javac的代码编译就开始了，写在源文件中的字符串是按照一定的编码方式的（如gbk），java编译器根据缺省的encoding来对源代码中的字符串做解码，在java bytecode中存储为unicode char。  </p>

<h3 id="section-3">数据库中的字符编码方式</h3>
<p>数据库中的东西都是二进制存放的，支持任何数据，理论上说，与编码并没有关系。不过，如果没有指定字符集，在排序、匹配的时候有问题，接口的地方也会出现问题。<br />
因此就涉及到以什么编码方式来保存到数据库中了。平常我们用数据库工具或者其他程序写数据库时，都是直接用系统编码方式，也就是gbk。但是，JDBC在访问数据库时，缺省是用数据库的字符集，通常为8859<em>1的，本来应该是gbk-&gt;unicode却变成了8859</em>1-&gt;unicode,就会出现乱码。连接串中加上参数可以强制jdbc按照gbk做转换。<br />
jdbc:mysql://localhost/test?useUnicode=true&amp;characterEncoding=GBK<br />
不过这样数据库还是只能支持gbk，如果写入big5码，同样会出现转换错误的问题。最佳方案还是用UTF8来编码，这样可以容纳unicode所有字符，覆盖了gbk、big5等各个字符集的范围。<br />
MySQL原来不支持UTF8，直到目前的最新版本4.1才加入unicode支持，但目前4.1版本还在alpha阶段。  </p>

<h3 id="swing">Swing的字符集问题</h3>
<p>从目前的试验看来，swing的组件会自动根据系统encoding做转换，并不需要干预。  </p>

]]></content>
  </entry>
  
</feed>
